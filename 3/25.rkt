#lang sicp
(#%require (only racket error))

(define (make-table)
  (let ((local-table (list '*table*))
        (my-assoc ((lambda (f) (lambda (k r) (f f k r)))
                   (lambda (fn keylist records)
                     (let ((rec (assoc (car keylist) (cdr records))))
                       (cond ((not rec) (cons records keylist))
                             ((null? (cdr keylist)) (cons rec (cdr keylist)))
                             ((not (assoc (cadr keylist) (cdr rec))) (cons (cdr rec) (cdr keylist)))
                             (else (fn fn (cdr keylist) rec))))))))
    
    (define (make-record keys val)
      (if (null? (cdr keys)) (cons (cons (car keys) val) nil)
          (cons (cons (car keys) (make-record (cdr keys) val)) nil)))
    
    (define (lookup keylist)
      (let ((ret (my-assoc keylist local-table)))
        (let ((subtable (car ret))
              (subkeys (cdr ret)))
          (if (null? subkeys)
              (cdr subtable)
              false))))
    
    (define (insert! keylist value)
      (let ((ret (my-assoc keylist local-table)))
        (let ((subtable (car ret))
              (subkeys (cdr ret)))
          (if (null? subkeys)
              (set-cdr! subtable value)
              (set-cdr! subtable (make-record subkeys value))))) 'ok)
    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            ((eq? m 'show) (display local-table))
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))

(put (list 1 3 4 5) 'v2)
(put (list 1 2 7) 'v1)
(operation-table 'show)
(get (list 1 3 4 5))
(put (list 1 2 7) 'v3)
(get (list 1 3 4))
(operation-table 'show)