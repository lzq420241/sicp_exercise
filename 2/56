#lang sicp
(#%require (only racket error))
(#%require "accumulate-n")
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))
(define (base e) (cadr e))
(define (exponent e) (caddr e))
(define (make-exponentiation b e)
  (cond ((=number? e 0) 1)
        ((=number? e 1) b)
        (else (list '** b e))))
(define (addend s) (cadr s))
(define (augend s)
  (if (null? (cdddr s)) (caddr s)
      (cons '+ (cddr s))))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p)
  (if (null? (cdddr p)) (caddr p)
      (cons '* (cddr p))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (op-convert op)
  (cond ((equal? op '+) +)
        ((equal? op '*) *)))
;expand single-elment list to single element
(define (expand e)
  (if (pair? e)
      (if (null? (cdr e)) (expand (car e)) e)
      e))
(define (make-op op init m1 m2)
  (let ((args (map (lambda (x) (expand x)) (append (list m1) m2))))
        (let ((num-result (accumulate (op-convert op)
                                      init
                                      (filter number? args)))
              (non-num-result (accumulate cons
                                          nil
                                          (filter (lambda (x) (not (number? x))) args))))
          (cond ((equal? non-num-result (list)) num-result)
                ((= init num-result) (if (null? (cdr non-num-result)) (car non-num-result)
                                         (cons op non-num-result)))
                ((and (= num-result 0) (equal? op '*)) 0)
                (else (append (list op num-result) non-num-result))))))  
     
(define (make-product m1 . m2)
  (make-op '* 1 m1 m2))

(define (make-sum a1 . a2)
  (make-op '+ 0 a1 a2))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        ((exponentiation? exp)
         (make-product (exponent exp)
                       (make-product (make-exponentiation (base exp)
                                                          (make-sum (exponent exp) -1))
                                     (deriv (base exp) var))))
        (else
         (error "unknown expression type -- DERIV" exp))))

(display (deriv '(* x y (+ 3 x 4)) 'x))
(newline)
(define p '(* x y (+ 3 x) z))
;(display (augend p))
(display (multiplicand p))
(newline)
(define s (make-sum 'a 'b '(+ a 3) 'd 'e))
(display (augend s))
(newline)
(display (make-sum '2 '3 '((4))))
(newline)
(display (make-product '2 'x '4))
(newline)
(display (deriv '(* 5 (** x 4)) 'x))
(newline)
